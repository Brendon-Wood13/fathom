<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fathom Reader</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }

    /* ── Theme: Clean (default) ──────────────────────────────────── */
    :root,
    .theme-clean {
      --bg: #fff;
      --text: #1a1a1a;
      --text-muted: #6b7280;
      --border: #e5e7eb;
      --font-heading: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      --line-height: 1.7;
      --header-border: 1px solid var(--border);
      --layer-2-color: #2563eb;
      --layer-2-bg: rgba(37, 99, 235, 0.07);
      --layer-2-border: rgba(37, 99, 235, 0.35);
      --layer-3-color: #7c3aed;
      --layer-3-bg: rgba(124, 58, 237, 0.07);
      --layer-3-border: rgba(124, 58, 237, 0.35);
      --code-bg: #f3f4f6;
      --code-text: inherit;
      --btn-bg: #fff;
      --btn-border: #d1d5db;
      --btn-hover: #f3f4f6;
      --bar-bg: rgba(255, 255, 255, 0.95);
      --active-btn-bg: #1a1a1a;
      --active-btn-text: #fff;
      --drop-border: #d1d5db;
      --ref-text: #374151;
    }

    /* ── Theme: Editorial ────────────────────────────────────────── */
    .theme-editorial {
      --bg: #faf8f4;
      --text: #2c2c2c;
      --text-muted: #7a7368;
      --border: #e0dbd3;
      --font-heading: Georgia, 'Times New Roman', Times, serif;
      --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      --line-height: 1.8;
      --header-border: 4px double var(--border);
      --layer-2-color: #0d7377;
      --layer-2-bg: rgba(13, 115, 119, 0.07);
      --layer-2-border: rgba(13, 115, 119, 0.35);
      --layer-3-color: #a0522d;
      --layer-3-bg: rgba(160, 82, 45, 0.07);
      --layer-3-border: rgba(160, 82, 45, 0.35);
      --code-bg: #f0ece4;
      --code-text: inherit;
      --btn-bg: #faf8f4;
      --btn-border: #d4cfc6;
      --btn-hover: #f0ece4;
      --bar-bg: rgba(250, 248, 244, 0.95);
      --active-btn-bg: #2c2c2c;
      --active-btn-text: #faf8f4;
      --drop-border: #d4cfc6;
      --ref-text: #4a4540;
    }

    /* ── Theme: Mono (dark) ──────────────────────────────────────── */
    .theme-mono {
      --bg: #1a1b1e;
      --text: #e4e4e7;
      --text-muted: #9ca3af;
      --border: #3f3f46;
      --font-heading: 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace;
      --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      --line-height: 1.7;
      --header-border: 1px solid var(--border);
      --layer-2-color: #22d3ee;
      --layer-2-bg: rgba(34, 211, 238, 0.1);
      --layer-2-border: rgba(34, 211, 238, 0.35);
      --layer-3-color: #f59e0b;
      --layer-3-bg: rgba(245, 158, 11, 0.1);
      --layer-3-border: rgba(245, 158, 11, 0.35);
      --code-bg: #27272a;
      --code-text: #e4e4e7;
      --btn-bg: #27272a;
      --btn-border: #3f3f46;
      --btn-hover: #3f3f46;
      --bar-bg: rgba(26, 27, 30, 0.95);
      --active-btn-bg: #e4e4e7;
      --active-btn-text: #1a1b1e;
      --drop-border: #3f3f46;
      --ref-text: #a1a1aa;
    }

    body {
      font-family: var(--font-body);
      max-width: 720px;
      margin: 0 auto;
      padding: 40px 20px;
      line-height: var(--line-height);
      color: var(--text);
      background: var(--bg);
    }

    /* File loader */
    #file-loader {
      text-align: center;
      padding: 80px 20px;
    }
    #file-loader h1 {
      font-size: 2em;
      font-family: var(--font-heading);
      margin-bottom: 8px;
    }
    #file-loader > p {
      color: var(--text-muted);
      margin-bottom: 40px;
    }
    #drop-zone {
      border: 2px dashed var(--drop-border);
      border-radius: 12px;
      padding: 48px 24px;
      margin-bottom: 20px;
      transition: border-color 0.15s, background 0.15s;
    }
    #drop-zone.dragover {
      border-color: var(--layer-2-color);
      background: var(--layer-2-bg);
    }
    #drop-zone p {
      margin: 4px 0;
      color: var(--text-muted);
    }
    #file-input {
      margin-top: 12px;
    }

    /* Document view */
    #document-view { display: none; }

    .layer-toggle-bar {
      position: sticky;
      top: 0;
      background: var(--bar-bg);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid var(--border);
      padding: 10px 0;
      z-index: 100;
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 24px;
    }
    .layer-toggle-bar .label {
      font-size: 13px;
      color: var(--text-muted);
      margin-right: 4px;
    }
    .layer-btn {
      padding: 5px 14px;
      border: 1px solid var(--btn-border);
      border-radius: 6px;
      background: var(--btn-bg);
      color: var(--text);
      cursor: pointer;
      font-size: 13px;
      font-family: inherit;
      transition: all 0.12s;
    }
    .layer-btn:hover { background: var(--btn-hover); }
    .layer-btn.active {
      background: var(--active-btn-bg);
      color: var(--active-btn-text);
      border-color: var(--active-btn-bg);
    }
    .layer-btn.active.layer-2 {
      background: var(--layer-2-color);
      border-color: var(--layer-2-color);
      color: #fff;
    }
    .layer-btn.active.layer-3 {
      background: var(--layer-3-color);
      border-color: var(--layer-3-color);
      color: #fff;
    }
    .theme-mono .layer-btn.active.layer-2,
    .theme-mono .layer-btn.active.layer-3 {
      color: #1a1b1e;
    }

    .fathom-header {
      border-bottom: var(--header-border);
      padding-bottom: 16px;
      margin-bottom: 32px;
    }
    .fathom-header h1 {
      font-family: var(--font-heading);
      font-size: 1.6em;
      margin: 0 0 8px;
    }
    .fathom-header .meta {
      font-size: 0.9em;
      color: var(--text-muted);
    }

    /* Body content */
    #doc-body h1 { font-family: var(--font-heading); font-size: 1.5em; margin: 32px 0 16px; }
    #doc-body h2 { font-family: var(--font-heading); font-size: 1.25em; margin: 28px 0 12px; }
    #doc-body h3 { font-family: var(--font-heading); font-size: 1.1em; margin: 24px 0 10px; }
    #doc-body p { margin: 0 0 16px; }
    #doc-body ol, #doc-body ul { margin: 0 0 16px; padding-left: 24px; }
    #doc-body li { margin-bottom: 8px; }
    #doc-body code {
      font-family: 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 0.88em;
      background: var(--code-bg);
      color: var(--code-text);
      padding: 2px 5px;
      border-radius: 3px;
    }

    /* Images */
    .fathom-image {
      max-width: 100%;
      height: auto;
      border-radius: 4px;
      margin: 8px 0;
    }
    .fathom-image-block {
      margin: 16px 0;
    }
    .fathom-image-block img {
      max-width: 100%;
      height: auto;
      border-radius: 4px;
    }

    /* Figures with captions */
    .fathom-figure {
      margin: 24px 0;
      padding: 0;
    }
    .fathom-figure img {
      max-width: 100%;
      height: auto;
      border-radius: 4px;
      display: block;
    }
    .fathom-figure figcaption {
      font-size: 0.85em;
      color: var(--text-muted);
      margin-top: 8px;
      line-height: 1.5;
    }

    /* Inline trigger (collapsed) */
    .fathom-trigger {
      cursor: pointer;
      text-decoration: underline;
      text-decoration-style: dotted;
      text-underline-offset: 3px;
      text-decoration-thickness: 1.5px;
      border-radius: 2px;
      transition: background 0.12s;
    }
    .fathom-trigger.layer-2 {
      color: var(--layer-2-color);
      text-decoration-color: var(--layer-2-color);
    }
    .fathom-trigger.layer-3 {
      color: var(--layer-3-color);
      text-decoration-color: var(--layer-3-color);
    }
    .fathom-trigger:hover {
      text-decoration-style: solid;
    }
    .fathom-trigger.layer-2:hover { background: var(--layer-2-bg); }
    .fathom-trigger.layer-3:hover { background: var(--layer-3-bg); }

    /* Inline expanded */
    .fathom-expanded {
      cursor: pointer;
      border-radius: 2px;
      padding: 0 1px;
      transition: background 0.12s;
    }
    .fathom-expanded.layer-2 { background: var(--layer-2-bg); }
    .fathom-expanded.layer-3 { background: var(--layer-3-bg); }

    /* Block insertion indicator (collapsed) */
    .fathom-block-indicator {
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 2px 0;
      margin: 4px 0;
      opacity: 0.45;
      transition: opacity 0.15s;
    }
    .fathom-block-indicator:hover { opacity: 1; }
    .fathom-block-indicator .indicator-line {
      flex: 1;
      border: none;
      border-top: 2px solid;
      margin: 0;
    }
    .fathom-block-indicator .indicator-caret {
      font-size: 9px;
      margin: 0 6px;
      user-select: none;
    }
    .fathom-block-indicator.layer-2 .indicator-line { border-color: var(--layer-2-border); }
    .fathom-block-indicator.layer-2 .indicator-caret { color: var(--layer-2-color); }
    .fathom-block-indicator.layer-3 .indicator-line { border-color: var(--layer-3-border); }
    .fathom-block-indicator.layer-3 .indicator-caret { color: var(--layer-3-color); }

    /* Block insertion expanded */
    .fathom-block-content {
      border-left: 3px solid;
      padding: 8px 0 8px 16px;
      margin: 8px 0;
      border-radius: 0 4px 4px 0;
    }
    .fathom-block-content.layer-2 {
      border-left-color: var(--layer-2-border);
      background: var(--layer-2-bg);
    }
    .fathom-block-content.layer-3 {
      border-left-color: var(--layer-3-border);
      background: var(--layer-3-bg);
    }
    .fathom-block-content p:last-child { margin-bottom: 0; }
    .fathom-block-collapse {
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 2px 0;
      margin-top: 4px;
      opacity: 0.45;
      transition: opacity 0.15s;
    }
    .fathom-block-collapse:hover { opacity: 1; }
    .fathom-block-collapse .indicator-line {
      flex: 1;
      border: none;
      border-top: 2px solid;
      margin: 0;
    }
    .fathom-block-collapse .indicator-caret {
      font-size: 9px;
      margin: 0 6px;
      user-select: none;
    }

    /* References */
    .fathom-ref {
      font-size: 0.75em;
      vertical-align: super;
      line-height: 0;
      margin-left: 1px;
    }
    .fathom-ref a {
      text-decoration: none;
      color: var(--layer-3-color);
    }
    .fathom-ref a:hover { text-decoration: underline; }

    #doc-references {
      border-top: 1px solid var(--border);
      margin-top: 40px;
      padding-top: 20px;
    }
    #doc-references h3 { margin-top: 0; font-size: 1em; }
    #doc-references ol {
      padding-left: 20px;
      font-size: 0.9em;
      color: var(--ref-text);
    }
    #doc-references li { margin-bottom: 6px; }
    #doc-references a { color: var(--layer-2-color); }

    /* Back-to-top / load-new button */
    .toolbar-right {
      margin-left: auto;
    }
    .toolbar-right button {
      padding: 4px 10px;
      border: 1px solid var(--btn-border);
      border-radius: 6px;
      background: var(--btn-bg);
      cursor: pointer;
      font-size: 12px;
      font-family: inherit;
      color: var(--text-muted);
    }
    .toolbar-right button:hover { background: var(--btn-hover); color: var(--text); }
  </style>
</head>
<body>
  <div id="app">
    <div id="file-loader">
      <h1>Fathom Reader</h1>
      <p>Load a .fathom document to begin reading.</p>
      <div id="drop-zone">
        <p>Drag &amp; drop a <strong>.fathom</strong> file here</p>
        <p style="font-size:0.85em">or</p>
        <input type="file" id="file-input" accept=".fathom,.txt">
      </div>
    </div>
    <div id="document-view">
      <div class="layer-toggle-bar" id="layer-bar"></div>
      <div class="fathom-header" id="doc-header"></div>
      <div id="doc-body"></div>
      <div id="doc-references"></div>
    </div>
  </div>

  <script>
  // ── FathomParser ──────────────────────────────────────────────────

  class FathomParser {
    constructor(source) {
      this.source = source;
      this.nodeId = 0;
    }

    nextId() {
      return 'n' + (this.nodeId++);
    }

    parse() {
      const { frontMatter, body, references } = this.splitSections();
      return {
        meta: this.parseFrontMatter(frontMatter),
        body: this.parseBody(body),
        references: this.parseReferences(references),
      };
    }

    splitSections() {
      const src = this.source.replace(/\r\n/g, '\n');
      // Front matter between first --- and second ---
      const firstDash = src.indexOf('---\n');
      if (firstDash === -1) throw new Error('Missing front matter');
      const secondDash = src.indexOf('\n---\n', firstDash + 4);
      if (secondDash === -1) throw new Error('Missing front matter closing ---');
      const frontMatter = src.slice(firstDash + 4, secondDash);
      const rest = src.slice(secondDash + 5);

      // References section
      const refDelim = '\n---references---\n';
      const refIdx = rest.indexOf(refDelim);
      let body, references;
      if (refIdx !== -1) {
        body = rest.slice(0, refIdx);
        references = rest.slice(refIdx + refDelim.length);
      } else {
        // Also try at start of rest (no leading newline)
        const refDelim2 = '---references---\n';
        if (rest.trimStart().startsWith(refDelim2)) {
          body = '';
          references = rest.trimStart().slice(refDelim2.length);
        } else {
          body = rest;
          references = '';
        }
      }
      return { frontMatter, body: body.trim(), references: references.trim() };
    }

    parseFrontMatter(text) {
      const meta = {};
      for (const line of text.split('\n')) {
        const trimmed = line.trim();
        if (!trimmed) continue;
        const colonIdx = trimmed.indexOf(':');
        if (colonIdx === -1) continue;
        const key = trimmed.slice(0, colonIdx).trim();
        const value = trimmed.slice(colonIdx + 1).trim();
        meta[key] = value;
      }
      // Parse layers: "1:What, 2:Why, 3:How"
      if (meta.layers) {
        meta.layers = meta.layers.split(',').map(s => {
          const [num, label] = s.trim().split(':');
          return { num: parseInt(num, 10), label: label.trim() };
        });
      }
      if (meta.default_layer) {
        meta.default_layer = parseInt(meta.default_layer, 10);
      }
      return meta;
    }

    parseReferences(text) {
      if (!text) return [];
      const refs = [];
      for (const line of text.split('\n')) {
        const trimmed = line.trim();
        if (!trimmed) continue;
        const m = trimmed.match(/^\[\^(\w+)\]\((\d+)\):\s*(.+)$/);
        if (m) {
          const citationText = m[3];
          // Extract URL if present at end
          const urlMatch = citationText.match(/\s+(https?:\/\/\S+)$/);
          refs.push({
            id: m[1],
            minLayer: parseInt(m[2], 10),
            text: urlMatch ? citationText.slice(0, urlMatch.index) : citationText,
            url: urlMatch ? urlMatch[1] : null,
          });
        }
      }
      return refs;
    }

    parseBody(text) {
      if (!text) return [];
      // Split into raw lines, then group into block-level constructs
      const blocks = [];
      let i = 0;
      const lines = text.split('\n');

      while (i < lines.length) {
        const line = lines[i];

        // Blank line
        if (line.trim() === '') {
          i++;
          continue;
        }

        // Heading
        const headingMatch = line.match(/^(#{1,6})\s+(.+)$/);
        if (headingMatch) {
          blocks.push({
            type: 'heading',
            level: headingMatch[1].length,
            content: this.parseInline(headingMatch[2]),
            id: this.nextId(),
          });
          i++;
          continue;
        }

        // Block insertion: starts with {+
        if (line.trimStart().startsWith('{+')) {
          const { node, endLine } = this.parseBlockInsertion(lines, i);
          blocks.push(node);
          i = endLine + 1;
          continue;
        }

        // Block-level image: line is only ![alt](src) or ![alt](src){...attrs...}
        const imgLineMatch = line.match(/^!\[([^\]]*)\]\(([^)]+)\)(\{([^}]*)\})?\s*$/);
        if (imgLineMatch) {
          const attrs = imgLineMatch[4] ? this.parseImageAttrs(imgLineMatch[4]) : { layer: null, caption: null };
          blocks.push({
            type: 'imageBlock',
            alt: imgLineMatch[1],
            src: imgLineMatch[2],
            layer: attrs.layer,
            caption: attrs.caption,
            id: this.nextId(),
          });
          i++;
          continue;
        }

        // Paragraph: collect lines until blank line or block-level construct
        let paraText = '';
        while (i < lines.length) {
          const pLine = lines[i];
          if (pLine.trim() === '') break;
          if (pLine.match(/^#{1,6}\s/)) break;
          if (pLine.trimStart().startsWith('{+')) break;
          if (pLine.match(/^!\[([^\]]*)\]\(([^)]+)\)(\{[^}]*\})?\s*$/)) break;
          if (paraText) paraText += '\n';
          paraText += pLine;
          i++;
        }
        if (paraText) {
          blocks.push({
            type: 'paragraph',
            content: this.parseInline(paraText),
            id: this.nextId(),
          });
        }
      }

      // Merge consecutive block insertions of the same layer into a single node
      const merged = [];
      for (const block of blocks) {
        if (block.type === 'blockInsertion' && merged.length > 0) {
          const prev = merged[merged.length - 1];
          if (prev.type === 'blockInsertion' && prev.layer === block.layer) {
            prev.content = prev.content.concat(block.content);
            continue;
          }
        }
        merged.push(block);
      }
      return merged;
    }

    parseBlockInsertion(lines, startLine) {
      // Collect the full text of the block insertion, handling brace balancing
      let fullText = lines[startLine];
      let depth = 0;
      // Count braces in this line
      for (const ch of fullText) {
        if (ch === '{') depth++;
        else if (ch === '}') depth--;
      }
      let endLine = startLine;
      while (depth > 0 && endLine + 1 < lines.length) {
        endLine++;
        fullText += '\n' + lines[endLine];
        for (const ch of lines[endLine]) {
          if (ch === '{') depth++;
          else if (ch === '}') depth--;
        }
      }

      // Extract layer number and content from {+N:...}
      const m = fullText.match(/^\s*\{\+(\d+):([\s\S]*)\}$/);
      if (!m) {
        return {
          node: { type: 'paragraph', content: [{ type: 'text', value: fullText }], id: this.nextId() },
          endLine,
        };
      }

      const layer = parseInt(m[1], 10);
      const innerText = m[2].trim();

      // Parse inner content as blocks (it can contain paragraphs, lists, etc.)
      const innerBlocks = this.parseBlockContent(innerText);

      return {
        node: {
          type: 'blockInsertion',
          layer,
          content: innerBlocks,
          id: this.nextId(),
        },
        endLine,
      };
    }

    parseBlockContent(text) {
      // Parse text that may contain paragraphs, lists, and inline markup
      const blocks = [];
      const lines = text.split('\n');
      let i = 0;

      while (i < lines.length) {
        const line = lines[i];
        if (line.trim() === '') { i++; continue; }

        // Ordered list — collect all items, skipping blank lines between them
        if (line.match(/^\d+\.\s/)) {
          const items = [];
          while (i < lines.length) {
            // Skip blank lines between list items
            while (i < lines.length && lines[i].trim() === '') i++;
            if (i >= lines.length || !lines[i].match(/^\d+\.\s/)) break;
            let itemText = lines[i].replace(/^\d+\.\s/, '');
            i++;
            // Continuation lines (not a new list item, not blank)
            while (i < lines.length && lines[i].trim() !== '' && !lines[i].match(/^\d+\.\s/)) {
              itemText += ' ' + lines[i].trim();
              i++;
            }
            items.push({
              type: 'listItem',
              content: this.parseInline(itemText),
              id: this.nextId(),
            });
          }
          blocks.push({ type: 'orderedList', items, id: this.nextId() });
          continue;
        }

        // Unordered list
        if (line.match(/^[-*]\s/)) {
          const items = [];
          while (i < lines.length && lines[i].match(/^[-*]\s/)) {
            const itemText = lines[i].replace(/^[-*]\s/, '');
            items.push({
              type: 'listItem',
              content: this.parseInline(itemText),
              id: this.nextId(),
            });
            i++;
          }
          blocks.push({ type: 'unorderedList', items, id: this.nextId() });
          continue;
        }

        // Paragraph
        let paraText = '';
        while (i < lines.length && lines[i].trim() !== '' && !lines[i].match(/^\d+\.\s/) && !lines[i].match(/^[-*]\s/)) {
          if (paraText) paraText += ' ';
          paraText += lines[i];
          i++;
        }
        if (paraText) {
          blocks.push({
            type: 'paragraph',
            content: this.parseInline(paraText),
            id: this.nextId(),
          });
        }
      }
      return blocks;
    }

    parseInline(text) {
      const nodes = [];
      let pos = 0;
      let plainBuf = '';

      const flushPlain = () => {
        if (plainBuf) {
          this.pushMarkdownNodes(nodes, plainBuf);
          plainBuf = '';
        }
      };

      while (pos < text.length) {
        // Image: ![alt](src) or ![alt](src){layer:N}
        if (text[pos] === '!' && pos + 1 < text.length && text[pos + 1] === '[') {
          const result = this.tryParseImage(text, pos);
          if (result) {
            flushPlain();
            nodes.push(result.node);
            pos = result.endPos;
            continue;
          }
        }

        // Backtick code span
        if (text[pos] === '`') {
          const end = text.indexOf('`', pos + 1);
          if (end !== -1) {
            flushPlain();
            nodes.push({ type: 'code', value: text.slice(pos + 1, end) });
            pos = end + 1;
            continue;
          }
        }

        // Reference marker: [^ID]
        if (text[pos] === '[' && pos + 1 < text.length && text[pos + 1] === '^') {
          const closeBracket = text.indexOf(']', pos + 2);
          if (closeBracket !== -1) {
            const refId = text.slice(pos + 2, closeBracket);
            if (refId.match(/^\w+$/)) {
              flushPlain();
              nodes.push({ type: 'refMarker', refId, id: this.nextId() });
              pos = closeBracket + 1;
              continue;
            }
          }
        }

        // Inline replacement: [trigger]{N:content}
        if (text[pos] === '[' && !(pos + 1 < text.length && text[pos + 1] === '^')) {
          const result = this.tryParseInlineReplacement(text, pos);
          if (result) {
            flushPlain();
            nodes.push(result.node);
            pos = result.endPos;
            continue;
          }
        }

        plainBuf += text[pos];
        pos++;
      }
      flushPlain();
      return nodes;
    }

    tryParseInlineReplacement(text, startPos) {
      // Try to parse [trigger]{N:content} starting at startPos (which is '[')
      // Find the matching ] — trigger text is plain (no nesting), but be careful with literal brackets
      let pos = startPos + 1;
      let bracketDepth = 1;
      while (pos < text.length && bracketDepth > 0) {
        if (text[pos] === '[') bracketDepth++;
        else if (text[pos] === ']') bracketDepth--;
        if (bracketDepth > 0) pos++;
      }
      if (bracketDepth !== 0) return null;
      const triggerText = text.slice(startPos + 1, pos);
      pos++; // skip ]

      // Must be followed by {N:
      if (pos >= text.length || text[pos] !== '{') return null;
      pos++; // skip {

      // Read layer number
      const layerMatch = text.slice(pos).match(/^(\d+):/);
      if (!layerMatch) return null;
      const layer = parseInt(layerMatch[1], 10);
      pos += layerMatch[0].length;

      // Read brace-balanced content
      let depth = 1;
      const contentStart = pos;
      while (pos < text.length && depth > 0) {
        if (text[pos] === '{') depth++;
        else if (text[pos] === '}') depth--;
        if (depth > 0) pos++;
      }
      if (depth !== 0) return null;

      const contentText = text.slice(contentStart, pos);
      pos++; // skip closing }

      return {
        node: {
          type: 'inlineReplacement',
          layer,
          trigger: this.parseInline(triggerText),
          replacement: this.parseInline(contentText),
          id: this.nextId(),
        },
        endPos: pos,
      };
    }

    tryParseImage(text, startPos) {
      // Parse ![alt](src) or ![alt](src){layer:N, caption:"..."} starting at startPos (which is '!')
      let pos = startPos + 2; // skip '!['
      // Find closing ]
      const closeBracket = text.indexOf(']', pos);
      if (closeBracket === -1) return null;
      const alt = text.slice(pos, closeBracket);
      pos = closeBracket + 1;

      // Must be followed by (
      if (pos >= text.length || text[pos] !== '(') return null;
      pos++; // skip (
      const closeParen = text.indexOf(')', pos);
      if (closeParen === -1) return null;
      const src = text.slice(pos, closeParen);
      pos = closeParen + 1;

      // Optional {layer:N, caption:"..."}
      let layer = null;
      let caption = null;
      if (pos < text.length && text[pos] === '{') {
        const closeBrace = text.indexOf('}', pos);
        if (closeBrace !== -1) {
          const attrStr = text.slice(pos + 1, closeBrace);
          const attrs = this.parseImageAttrs(attrStr);
          layer = attrs.layer;
          caption = attrs.caption;
          pos = closeBrace + 1;
        }
      }

      return {
        node: { type: 'image', alt, src, layer, caption, id: this.nextId() },
        endPos: pos,
      };
    }

    parseImageAttrs(attrStr) {
      let layer = null;
      let caption = null;
      const layerMatch = attrStr.match(/layer:\s*(\d+)/);
      if (layerMatch) layer = parseInt(layerMatch[1], 10);
      const captionMatch = attrStr.match(/caption:\s*"([^"]*)"/);
      if (captionMatch) caption = captionMatch[1];
      return { layer, caption };
    }

    pushMarkdownNodes(nodes, text) {
      // Process bold, italic within plain text
      // Pattern: **bold**, *italic*
      const parts = this.splitMarkdown(text);
      for (const part of parts) {
        nodes.push(part);
      }
    }

    splitMarkdown(text) {
      const result = [];
      // Process **bold** first, then *italic*
      const boldRe = /\*\*(.+?)\*\*/g;
      let lastIdx = 0;
      let m;
      while ((m = boldRe.exec(text)) !== null) {
        if (m.index > lastIdx) {
          this.pushItalicNodes(result, text.slice(lastIdx, m.index));
        }
        result.push({ type: 'bold', content: this.splitItalic(m[1]) });
        lastIdx = boldRe.lastIndex;
      }
      if (lastIdx < text.length) {
        this.pushItalicNodes(result, text.slice(lastIdx));
      }
      return result;
    }

    pushItalicNodes(nodes, text) {
      for (const part of this.splitItalic(text)) {
        nodes.push(part);
      }
    }

    splitItalic(text) {
      const result = [];
      const italicRe = /\*(.+?)\*/g;
      let lastIdx = 0;
      let m;
      while ((m = italicRe.exec(text)) !== null) {
        if (m.index > lastIdx) {
          result.push({ type: 'text', value: text.slice(lastIdx, m.index) });
        }
        result.push({ type: 'italic', value: m[1] });
        lastIdx = italicRe.lastIndex;
      }
      if (lastIdx < text.length) {
        result.push({ type: 'text', value: text.slice(lastIdx) });
      }
      return result;
    }
  }

  // ── FathomState ───────────────────────────────────────────────────

  class FathomState {
    constructor() {
      this.globalLayer = 1;
      this.toggledNodes = new Set();
      this.meta = null;
      this.references = [];
      this.listeners = [];
    }

    init(meta, references) {
      this.meta = meta;
      this.references = references;
      this.globalLayer = meta.default_layer || 1;
      this.theme = meta.theme || 'clean';
      this.toggledNodes.clear();
    }

    setGlobalLayer(n) {
      this.globalLayer = n;
      this.toggledNodes.clear();
      this.notify();
    }

    toggleNode(nodeId) {
      if (this.toggledNodes.has(nodeId)) {
        this.toggledNodes.delete(nodeId);
      } else {
        this.toggledNodes.add(nodeId);
      }
      this.notify();
    }

    isExpanded(nodeId, nodeLayer) {
      const globallyExpanded = nodeLayer <= this.globalLayer;
      const toggled = this.toggledNodes.has(nodeId);
      return globallyExpanded ? !toggled : toggled;
    }

    getRefByid(id) {
      return this.references.find(r => r.id === id);
    }

    isRefVisible(refId) {
      const ref = this.getRefByid(refId);
      if (!ref) return false;
      return ref.minLayer <= this.globalLayer;
    }

    onChange(fn) {
      this.listeners.push(fn);
    }

    notify() {
      for (const fn of this.listeners) fn();
    }
  }

  // ── FathomRenderer ────────────────────────────────────────────────

  class FathomRenderer {
    constructor(state) {
      this.state = state;
    }

    renderDocument(ast) {
      this.ast = ast;
      this.renderHeader();
      this.renderLayerBar();
      this.renderBody();
      this.renderReferences();
    }

    renderHeader() {
      const header = document.getElementById('doc-header');
      const meta = this.state.meta;
      let html = `<h1>${this.escHtml(meta.title || 'Untitled')}</h1>`;
      const parts = [];
      if (meta.author) parts.push(this.escHtml(meta.author));
      if (meta.date) parts.push(this.escHtml(meta.date));
      if (parts.length) {
        html += `<div class="meta">${parts.join(' · ')}</div>`;
      }
      header.innerHTML = html;
    }

    renderLayerBar() {
      const bar = document.getElementById('layer-bar');
      bar.innerHTML = '';
      const label = document.createElement('span');
      label.className = 'label';
      label.textContent = 'Depth:';
      bar.appendChild(label);

      for (const layer of this.state.meta.layers) {
        const btn = document.createElement('button');
        btn.className = 'layer-btn';
        if (layer.num >= 2) btn.classList.add('layer-' + layer.num);
        btn.textContent = layer.label;
        btn.title = `Layer ${layer.num}: ${layer.label}`;
        if (layer.num === this.state.globalLayer) btn.classList.add('active');
        btn.addEventListener('click', () => {
          this.state.setGlobalLayer(layer.num);
        });
        bar.appendChild(btn);
      }

      // Load new file button
      const right = document.createElement('span');
      right.className = 'toolbar-right';
      const loadBtn = document.createElement('button');
      const hasDocParam = new URLSearchParams(window.location.search).has('doc');
      loadBtn.textContent = hasDocParam ? 'Back' : 'Load new file';
      loadBtn.addEventListener('click', () => {
        if (hasDocParam && document.referrer && new URL(document.referrer).origin === window.location.origin) {
          history.back();
        } else if (hasDocParam) {
          window.location.href = window.location.pathname.replace(/[^/]*$/, '') + 'index.html';
        } else {
          document.getElementById('document-view').style.display = 'none';
          document.getElementById('file-loader').style.display = 'block';
        }
      });
      right.appendChild(loadBtn);
      bar.appendChild(right);
    }

    renderBody() {
      const container = document.getElementById('doc-body');
      container.innerHTML = '';
      for (const block of this.ast.body) {
        const el = this.renderBlock(block);
        if (el) container.appendChild(el);
      }
    }

    renderReferences() {
      const container = document.getElementById('doc-references');
      const visibleRefs = this.state.references.filter(
        r => r.minLayer <= this.state.globalLayer
      );
      if (visibleRefs.length === 0) {
        container.innerHTML = '';
        return;
      }
      let html = '<h3>References</h3><ol>';
      for (const ref of this.state.references) {
        if (ref.minLayer > this.state.globalLayer) continue;
        html += `<li id="ref-${this.escHtml(ref.id)}">`;
        html += this.escHtml(ref.text);
        if (ref.url) {
          html += ` <a href="${this.escHtml(ref.url)}" target="_blank" rel="noopener">${this.escHtml(ref.url)}</a>`;
        }
        html += '</li>';
      }
      html += '</ol>';
      container.innerHTML = html;
    }

    renderBlock(block) {
      switch (block.type) {
        case 'heading': return this.renderHeading(block);
        case 'paragraph': return this.renderParagraph(block);
        case 'blockInsertion': return this.renderBlockInsertion(block);
        case 'orderedList': return this.renderOrderedList(block);
        case 'unorderedList': return this.renderUnorderedList(block);
        case 'imageBlock': return this.renderImageBlock(block);
        default: return null;
      }
    }

    renderHeading(block) {
      const el = document.createElement('h' + block.level);
      this.appendInlineNodes(el, block.content);
      return el;
    }

    renderParagraph(block) {
      const el = document.createElement('p');
      this.appendInlineNodes(el, block.content);
      return el;
    }

    renderOrderedList(block) {
      const ol = document.createElement('ol');
      for (const item of block.items) {
        const li = document.createElement('li');
        this.appendInlineNodes(li, item.content);
        ol.appendChild(li);
      }
      return ol;
    }

    renderUnorderedList(block) {
      const ul = document.createElement('ul');
      for (const item of block.items) {
        const li = document.createElement('li');
        this.appendInlineNodes(li, item.content);
        ul.appendChild(li);
      }
      return ul;
    }

    renderImageBlock(block) {
      if (block.layer !== null && block.layer > this.state.globalLayer) return null;
      if (block.caption) {
        const figure = document.createElement('figure');
        figure.className = 'fathom-figure';
        const img = document.createElement('img');
        img.src = this.resolveImageSrc(block.src);
        img.alt = block.alt;
        figure.appendChild(img);
        const figcaption = document.createElement('figcaption');
        figcaption.textContent = block.caption;
        figure.appendChild(figcaption);
        return figure;
      }
      const div = document.createElement('div');
      div.className = 'fathom-image-block';
      const img = document.createElement('img');
      img.src = this.resolveImageSrc(block.src);
      img.alt = block.alt;
      div.appendChild(img);
      return div;
    }

    renderBlockInsertion(block) {
      const expanded = this.state.isExpanded(block.id, block.layer);

      if (expanded) {
        const wrapper = document.createElement('div');
        wrapper.className = `fathom-block-content layer-${block.layer}`;
        wrapper.dataset.nodeId = block.id;
        for (const child of block.content) {
          const el = this.renderBlock(child);
          if (el) wrapper.appendChild(el);
        }
        // Collapse indicator at bottom
        const collapse = document.createElement('div');
        collapse.className = 'fathom-block-collapse';
        collapse.dataset.nodeId = block.id;
        collapse.setAttribute('role', 'button');
        collapse.setAttribute('tabindex', '0');
        collapse.title = 'Collapse';
        collapse.innerHTML =
          '<hr class="indicator-line" style="border-color: var(--layer-' + block.layer + '-border)">' +
          '<span class="indicator-caret" style="color: var(--layer-' + block.layer + '-color)">&#9650;</span>' +
          '<hr class="indicator-line" style="border-color: var(--layer-' + block.layer + '-border)">';
        collapse.addEventListener('click', (e) => {
          e.stopPropagation();
          this.state.toggleNode(block.id);
        });
        collapse.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            this.state.toggleNode(block.id);
          }
        });
        wrapper.appendChild(collapse);
        return wrapper;
      } else {
        // Show indicator
        const indicator = document.createElement('div');
        indicator.className = `fathom-block-indicator layer-${block.layer}`;
        indicator.dataset.nodeId = block.id;
        indicator.setAttribute('role', 'button');
        indicator.setAttribute('tabindex', '0');
        indicator.title = `Expand (Layer ${block.layer})`;
        indicator.innerHTML =
          '<hr class="indicator-line">' +
          '<span class="indicator-caret">&#9660;</span>' +
          '<hr class="indicator-line">';
        indicator.addEventListener('click', (e) => {
          e.stopPropagation();
          this.state.toggleNode(block.id);
        });
        indicator.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            this.state.toggleNode(block.id);
          }
        });
        return indicator;
      }
    }

    appendInlineNodes(parent, nodes) {
      for (const node of nodes) {
        const el = this.renderInlineNode(node);
        if (el) parent.appendChild(el);
      }
    }

    renderInlineNode(node) {
      switch (node.type) {
        case 'text': return document.createTextNode(node.value);
        case 'bold': {
          const strong = document.createElement('strong');
          if (node.content) {
            for (const child of node.content) {
              strong.appendChild(this.renderInlineNode(child));
            }
          } else {
            strong.textContent = node.value || '';
          }
          return strong;
        }
        case 'italic': {
          const em = document.createElement('em');
          em.textContent = node.value;
          return em;
        }
        case 'code': {
          const code = document.createElement('code');
          code.textContent = node.value;
          return code;
        }
        case 'image': {
          if (node.layer !== null && node.layer > this.state.globalLayer) {
            return document.createTextNode('');
          }
          const img = document.createElement('img');
          img.src = this.resolveImageSrc(node.src);
          img.alt = node.alt;
          if (node.caption) {
            const figure = document.createElement('figure');
            figure.className = 'fathom-figure';
            figure.appendChild(img);
            const figcaption = document.createElement('figcaption');
            figcaption.textContent = node.caption;
            figure.appendChild(figcaption);
            return figure;
          }
          img.className = 'fathom-image';
          return img;
        }
        case 'refMarker': return this.renderRefMarker(node);
        case 'inlineReplacement': return this.renderInlineReplacement(node);
        default: return document.createTextNode('');
      }
    }

    renderRefMarker(node) {
      if (!this.state.isRefVisible(node.refId)) {
        return document.createTextNode('');
      }
      const sup = document.createElement('sup');
      sup.className = 'fathom-ref';
      const a = document.createElement('a');
      a.href = '#ref-' + node.refId;
      a.textContent = '[' + node.refId + ']';
      const ref = this.state.getRefByid(node.refId);
      if (ref) a.title = ref.text;
      sup.appendChild(a);
      return sup;
    }

    renderInlineReplacement(node) {
      const expanded = this.state.isExpanded(node.id, node.layer);
      const span = document.createElement('span');
      span.dataset.nodeId = node.id;
      span.setAttribute('role', 'button');
      span.setAttribute('tabindex', '0');

      if (expanded) {
        span.className = `fathom-expanded layer-${node.layer}`;
        span.setAttribute('aria-expanded', 'true');
        span.title = 'Click to collapse';
        this.appendInlineNodes(span, node.replacement);
      } else {
        span.className = `fathom-trigger layer-${node.layer}`;
        span.setAttribute('aria-expanded', 'false');
        span.title = `Click to expand (Layer ${node.layer})`;
        this.appendInlineNodes(span, node.trigger);
      }

      span.addEventListener('click', (e) => {
        e.stopPropagation();
        this.state.toggleNode(node.id);
      });
      span.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          e.stopPropagation();
          this.state.toggleNode(node.id);
        }
      });

      return span;
    }

    resolveImageSrc(src) {
      if (!src) return src;
      if (src.match(/^https?:\/\//)) return src;
      const base = this.state.docBaseUrl;
      if (!base) return src;
      // Resolve relative path against document base URL
      try {
        return new URL(src, new URL(base, window.location.href)).href;
      } catch (e) {
        return base + src;
      }
    }

    escHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }
  }

  // ── FathomApp ─────────────────────────────────────────────────────

  class FathomApp {
    constructor() {
      this.state = new FathomState();
      this.renderer = new FathomRenderer(this.state);
      this.docBaseUrl = '';
      this.state.onChange(() => this.rerender());
      this.setupFileLoading();

      // Auto-load from ?doc= URL parameter
      const params = new URLSearchParams(window.location.search);
      const docUrl = params.get('doc');
      if (docUrl) this.loadFromUrl(docUrl);
    }

    setupFileLoading() {
      const dropZone = document.getElementById('drop-zone');
      const fileInput = document.getElementById('file-input');

      dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('dragover');
      });
      dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('dragover');
      });
      dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file) this.readFile(file);
      });

      fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) this.readFile(file);
      });
    }

    readFile(file) {
      const reader = new FileReader();
      reader.onload = (e) => this.loadDocument(e.target.result);
      reader.readAsText(file);
    }

    loadFromUrl(url) {
      // Store base path for resolving relative image URLs
      this.docBaseUrl = url.substring(0, url.lastIndexOf('/') + 1);
      fetch(url)
        .then(r => { if (!r.ok) throw new Error('Failed to load ' + url); return r.text(); })
        .then(source => this.loadDocument(source))
        .catch(err => {
          alert('Error loading document: ' + err.message);
          console.error(err);
        });
    }

    loadDocument(source) {
      try {
        const parser = new FathomParser(source);
        const ast = parser.parse();

        this.state.init(ast.meta, ast.references);
        this.state.docBaseUrl = this.docBaseUrl || '';
        this.ast = ast;

        document.body.className = 'theme-' + this.state.theme;
        document.getElementById('file-loader').style.display = 'none';
        document.getElementById('document-view').style.display = 'block';
        document.title = ast.meta.title || 'Fathom Reader';

        this.renderer.renderDocument(ast);
      } catch (err) {
        alert('Error parsing .fathom file: ' + err.message);
        console.error(err);
      }
    }

    rerender() {
      this.renderer.renderDocument(this.ast);
    }
  }

  // ── Initialize ────────────────────────────────────────────────────

  const app = new FathomApp();
  </script>
</body>
</html>
